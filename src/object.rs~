use chrono::{DateTime, Utc};

pub type Inception = DateTime<Utc>;

pub trait Fundamental {
    fn composed(&self) -> bool;
    fn flatten(&self) -> impl Fundamental;
}

#[derive(Clone)]
pub struct PureObject {
    name: String,
    data: Data,
    inception: Inception,
}

#[derive(Clone)]
pub struct Composition {
    /// The inception date of `method` matters here!
    method: PureObject,
    arguments: Vec<PureObject>,
}

#[derive(Clone)]
pub enum Data {
    Reference(String),
    Bytes(Vec<u8>),
}

#[derive(Clone)]
pub struct Object {
    initial: PureObject,
    composition_stack: Vec<Composition>,
    /// `transients` holds prior states of a flattened or overwritten object.
    /// It should solely contain states that other objects referenced before.
    /// It may also be used to cache previous evaluations to speed things up.
    /// If a transient is no longer needed, it should be deleted, either when
    /// collecting garbage or the next time the object is actually flattened.
    transients: Vec<PureObject>,
}

impl Object {
    pub fn promote(pure_object: &PureObject) -> Self {
        Self {
            initial: pure_object.clone(),
            composition_stack: vec![],
            // Clearing `transients` here is definitely wrong.
            // TODO don't clear transients when promoting a PureObject!!!
            transients: vec![],
        }
    }

    pub fn evaluate(&self, up_to: Inception) -> impl Fundamental {
        todo!();
	self.clone()
    }
}

impl Fundamental for PureObject {
    fn composed(&self) -> bool {
        false
    }

    fn flatten(&self) -> impl Fundamental {
        Object::promote(self)
    }
}

impl Fundamental for Object {
    fn composed(&self) -> bool {
        !self.composition_stack.is_empty()
    }

    fn flatten(&self) -> impl Fundamental {
        todo!();
        self.clone()
    }
}
